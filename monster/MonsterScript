local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local combatEvent = ReplicatedStorage:WaitForChild("CombatEvent")
local monster = script.Parent
local isBattleActive = false 

-- ==============================================================================
-- [ÏÑ§Ï†ï] 
-- ==============================================================================
local MONSTER_CONFIG = {
	name = "Red Cube",
	maxHP = 20,
	atk = 5,
	def = 1,
	maxSP = 3,      
	startSP = 1,    
	spRegen = 1,    
	respawnTime = 5 
}

-- [ÏàòÏ†ïÎê®] ÎìúÎûç ÏïÑÏù¥ÌÖú Î∞è Í≤ΩÌóòÏπò ÏÑ§Ï†ï
local DROP_CONFIG = {
	gold = 10,    -- ÌôïÏ†ï Í≥®Îìú
	exp = 35,     -- [Ï∂îÍ∞Ä] ÌöçÎìù Í≤ΩÌóòÏπò (1Î†àÎ≤® ÌÜµÏù¥ 100Ïù¥ÎãàÍπå 3ÎßàÎ¶¨ Ïû°ÏúºÎ©¥ Î†ôÏóÖ)
	items = {
		{name = "Red Brick", type = "Material", chance = 0.5, icon = "üß±", stat = "Ïû¨Î£å"} 
	}
}

local SKILL_CONFIG = {
	ATK = {cost = 1}, 
	BLK = {cost = 1}, 
	SPC = {cost = 2, minTurn = 2, cooldown = 2}
}

local PLAYER_SKILL_CONFIG = {
	SPC = {cost = 2, minTurn = 2, cooldown = 2}
}

-- ÌîåÎ†àÏù¥Ïñ¥ Ïä§ÌÉØ (ÏûÑÏãú)
local PLAYER_STATS = {
	maxHP = 40,
	currentHP = 40,
	atk = 8,
	def = 2
}

local battleState = {} 

--------------------------------------------------------------------------------
-- Í∏∞Î≥∏ Í∏∞Îä•Îì§
--------------------------------------------------------------------------------
local function respawnMonster()
	monster.Transparency = 1
	monster.CanCollide = false
	monster.Anchored = true
	task.wait(MONSTER_CONFIG.respawnTime)
	monster.Transparency = 0
	monster.CanCollide = true
	monster.Color = Color3.fromRGB(255, 0, 0)
	isBattleActive = false 
	print("‚ôªÔ∏è Î™¨Ïä§ÌÑ∞ Î¶¨Ïä§Ìè∞")
end

local function repositionPlayer(character)
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if rootPart then
		local direction = (rootPart.Position - monster.Position).Unit
		local newPos = monster.Position + (direction * 15)
		rootPart.CFrame = CFrame.new(newPos, monster.Position)
	end
end

local function freezePlayer(character, freeze)
	local humanoid = character:FindFirstChild("Humanoid")
	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if humanoid and rootPart then
		if freeze then
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
			rootPart.Anchored = true
		else
			humanoid.WalkSpeed = 35 
			humanoid.JumpPower = 60
			rootPart.Anchored = false
		end
	end
end

local function generateMonsterActions(userId)
	local state = battleState[userId]
	if not state then return {} end

	local mState = state.monsterStats
	local currentSP = mState.currentSP
	local currentTurn = state.turnCount
	local nextSpecialTurn = state.monsterNextSpecialTurn

	local pattern = {}
	local actions = {"ATK", "BLK"} 

	local simSP = currentSP

	for i = 1, mState.maxSP do
		local chosenAction = "-" 

		if currentTurn >= SKILL_CONFIG.SPC.minTurn and 
			currentTurn >= nextSpecialTurn and 
			simSP >= SKILL_CONFIG.SPC.cost then

			chosenAction = "SPC"
			simSP = simSP - SKILL_CONFIG.SPC.cost
			state.monsterNextSpecialTurn = currentTurn + SKILL_CONFIG.SPC.cooldown + 1

		elseif simSP >= SKILL_CONFIG.ATK.cost then
			local randomPick = actions[math.random(1, #actions)]
			chosenAction = randomPick
			simSP = simSP - SKILL_CONFIG[randomPick].cost
		else
			chosenAction = "-"
		end
		table.insert(pattern, chosenAction)
	end
	return pattern
end

--------------------------------------------------------------------------------
-- ÌÑ¥ ÌåêÏ†ï Î∞è Î≥¥ÏÉÅ ÏßÄÍ∏â
--------------------------------------------------------------------------------
local function resolveTurn(player, playerActions)
	local state = battleState[player.UserId]
	if not state then return end

	local pStats = state.playerStats
	local mStats = state.monsterStats
	local mActions = state.monsterActions
	local currentTurn = state.turnCount

	local turnLog = {}
	local maxSlots = math.max(#playerActions, #mActions)

	for i = 1, maxSlots do
		local pAct = playerActions[i] or "-"
		local mAct = mActions[i] or "-"

		-- ÏΩîÏä§Ìä∏ Î∞è Ïø®ÌÉÄÏûÑ Ï≤¥ÌÅ¨ (ÏÉùÎûµ ÏóÜÏù¥ Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ)
		local mCost = SKILL_CONFIG[mAct] and SKILL_CONFIG[mAct].cost or 0
		if mStats.currentSP >= mCost then
			mStats.currentSP = mStats.currentSP - mCost
		else
			mAct = "-" 
		end

		if pAct == "SPC" then
			if currentTurn >= PLAYER_SKILL_CONFIG.SPC.minTurn and 
				currentTurn >= state.playerNextSpecialTurn then
				state.playerNextSpecialTurn = currentTurn + PLAYER_SKILL_CONFIG.SPC.cooldown + 1
			else
				pAct = "-" 
			end
		end

		-- Îç∞ÎØ∏ÏßÄ Í≥ÑÏÇ∞
		local pDamageTaken = 0
		local mDamageTaken = 0

		if mAct == "ATK" or mAct == "SPC" then
			local dmg = mStats.atk
			if mAct == "SPC" then dmg = dmg * 1.5 end 
			if pAct == "BLK" then dmg = math.max(0, dmg - (pStats.def + 5))
			else dmg = math.max(0, dmg - pStats.def) end
			pDamageTaken = dmg
		end

		if pAct == "ATK" or pAct == "SPC" then
			local dmg = pStats.atk
			if pAct == "SPC" then dmg = dmg * 2 end 
			if mAct == "BLK" then dmg = math.max(0, dmg - (mStats.def + 5))
			else dmg = math.max(0, dmg - mStats.def) end
			mDamageTaken = dmg
		end

		pStats.currentHP = math.max(0, pStats.currentHP - pDamageTaken)
		mStats.currentHP = math.max(0, mStats.currentHP - mDamageTaken)

		table.insert(turnLog, {
			slot = i, pAction = pAct, mAction = mAct, pDmg = pDamageTaken, mDmg = mDamageTaken
		})
	end

	state.turnCount = state.turnCount + 1
	mStats.currentSP = mStats.currentSP + MONSTER_CONFIG.spRegen 

	local nextMonsterActions = generateMonsterActions(player.UserId)
	state.monsterActions = nextMonsterActions

	local resultData = {
		turnLog = turnLog,
		finalPHP = pStats.currentHP, finalMHP = mStats.currentHP,
		pMax = pStats.maxHP, mMax = mStats.maxHP,
		nextPattern = nextMonsterActions,
		gameResult = nil
	}

	if pStats.currentHP <= 0 then resultData.gameResult = "LOSE" end
	if mStats.currentHP <= 0 then resultData.gameResult = "WIN" end

	combatEvent:FireClient(player, "ShowResult", resultData)

	if resultData.gameResult then
		battleState[player.UserId] = nil
		if resultData.gameResult == "WIN" then 
			-- [ÏàòÏ†ïÎê®] Î≥¥ÏÉÅ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (Í≤ΩÌóòÏπò Ìè¨Ìï®)
			local rewardData = {
				gold = DROP_CONFIG.gold,
				exp = DROP_CONFIG.exp, -- Í≤ΩÌóòÏπò Ï∂îÍ∞Ä
				items = {}
			}

			for _, itemInfo in ipairs(DROP_CONFIG.items) do
				if math.random() <= itemInfo.chance then
					table.insert(rewardData.items, itemInfo)
				end
			end

			-- ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î°ú Î≥¥ÏÉÅ Ï†ÑÏÜ°
			combatEvent:FireClient(player, "Reward", rewardData)

			respawnMonster() 
		else
			isBattleActive = false 
		end
	end
end

--------------------------------------------------------------------------------
-- Ïù¥Î≤§Ìä∏ Ïó∞Í≤∞
--------------------------------------------------------------------------------
combatEvent.OnServerEvent:Connect(function(player, action, data)
	if action == "SubmitActions" then
		resolveTurn(player, data)
	elseif action == "EndBattle" then
		freezePlayer(player.Character, false)
		combatEvent:FireClient(player, "End")
	end
end)

monster.Touched:Connect(function(hit)
	if isBattleActive then return end
	local character = hit.Parent
	local player = Players:GetPlayerFromCharacter(character)

	if player then
		isBattleActive = true
		repositionPlayer(character)
		freezePlayer(character, true)

		local initialActions = generateMonsterActions(player.UserId) 

		battleState[player.UserId] = {
			turnCount = 1,          
			monsterNextSpecialTurn = 0,
			playerNextSpecialTurn = 0,
			playerStats = { maxHP=PLAYER_STATS.maxHP, currentHP=PLAYER_STATS.currentHP, atk=PLAYER_STATS.atk, def=PLAYER_STATS.def },
			monsterStats = { maxHP=MONSTER_CONFIG.maxHP, currentHP=MONSTER_CONFIG.maxHP, atk=MONSTER_CONFIG.atk, def=MONSTER_CONFIG.def, maxSP=MONSTER_CONFIG.maxSP, currentSP=MONSTER_CONFIG.startSP },
			monsterActions = initialActions 
		}

		local startData = {
			monsterName = MONSTER_CONFIG.name,
			monsterMaxSP = MONSTER_CONFIG.maxSP,
			monsterActions = initialActions,
			playerStats = PLAYER_STATS,
			monsterStats = battleState[player.UserId].monsterStats
		}
		combatEvent:FireClient(player, "Start", startData)
	end
end)
